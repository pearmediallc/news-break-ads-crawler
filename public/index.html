<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NewsBreak Ads Crawler - Control Panel</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        .header {
            background: white;
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        .control-panel {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .extraction-form {
            display: grid;
            grid-template-columns: 1fr 150px 150px 150px;
            gap: 15px;
            align-items: end;
        }

        .form-group {
            display: flex;
            flex-direction: column;
        }

        .form-group label {
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
        }

        .form-group input, .form-group select {
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-danger {
            background: #ef4444;
            color: white;
        }

        .btn-success {
            background: #10b981;
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .status-panel {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .status-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .status-badge {
            display: inline-block;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
        }

        .status-running {
            background: #fbbf24;
            color: #78350f;
        }

        .status-completed {
            background: #34d399;
            color: #064e3b;
        }

        .status-failed {
            background: #f87171;
            color: #7f1d1d;
        }

        .status-stopped {
            background: #9ca3af;
            color: #1f2937;
        }

        .logs-container {
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: white;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .stat-number {
            font-size: 36px;
            font-weight: bold;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .stat-label {
            color: #666;
            font-size: 14px;
            margin-top: 5px;
        }

        .ads-container {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .ads-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .ads-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 20px;
        }

        .ad-card {
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            padding: 15px;
            transition: all 0.3s;
        }

        .ad-card:hover {
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }

        .ad-advertiser {
            font-weight: 600;
            color: #667eea;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .ad-headline {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 8px;
            color: #1f2937;
            line-height: 1.4;
        }

        .ad-body {
            color: #666;
            font-size: 14px;
            margin-bottom: 10px;
            line-height: 1.5;
        }

        .ad-link {
            display: inline-block;
            color: #667eea;
            text-decoration: none;
            font-size: 13px;
            padding: 5px 10px;
            background: #f3f4f6;
            border-radius: 6px;
        }

        .ad-link:hover {
            background: #667eea;
            color: white;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .loading.active {
            display: block;
        }

        .spinner {
            border: 3px solid #f3f4f6;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .alert {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .alert-success {
            background: #d1fae5;
            color: #065f46;
        }

        .alert-error {
            background: #fee2e2;
            color: #991b1b;
        }

        .alert-info {
            background: #dbeafe;
            color: #1e40af;
        }

        .hidden {
            display: none;
        }

        /* Animation for new ads */
        @keyframes slideInNew {
            0% {
                opacity: 0;
                transform: translateY(-20px) scale(0.95);
                border: 2px solid #10b981;
                box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
            }
            50% {
                border: 2px solid #10b981;
                box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scale(1);
                border: 1px solid #e5e7eb;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            }
        }

        .new-ad {
            animation: slideInNew 0.5s ease-out;
        }

        /* Real-time status indicator */
        .realtime-status {
            display: inline-block;
            width: 8px;
            height: 8px;
            background: #10b981;
            border-radius: 50%;
            margin-left: 5px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h1>🎯 NewsBreak Ads Crawler Control Panel <span style="font-size: 0.6em; color: #666; font-weight: normal;">v1.4</span> <span id="realtimeIndicator" class="realtime-status" style="display: none;" title="Real-time updates connected"></span></h1>
                    <p>Extract and manage advertisements from NewsBreak pages</p>
                </div>
                <div style="display: flex; gap: 10px;">
                    <button onclick="window.location.href='/users'" class="btn" style="background: #6366f1; color: white;">
                        👥 Manage Users
                    </button>
                    <button onclick="logout()" class="btn" style="background: #ef4444; color: white;">
                        🚪 Logout
                    </button>
                </div>
            </div>
        </div>

        <div class="control-panel">
            <h2>Start New Extraction <span style="background: #10b981; color: white; padding: 2px 8px; border-radius: 4px; font-size: 12px; margin-left: 10px;">v1.2</span></h2>
            <form class="extraction-form" id="extractionForm">
                <div class="form-group">
                    <label for="url">NewsBreak URL</label>
                    <input
                        type="url"
                        id="url"
                        placeholder="https://www.newsbreak.com/new-york-ny"
                        value="https://www.newsbreak.com/new-york-ny"
                        required
                    >
                </div>
                <div class="form-group">
                    <label for="extractionMode">Extraction Mode</label>
                    <select id="extractionMode" onchange="toggleDurationField()" required>
                        <option value="timed" selected>⏱️ Timed Extraction</option>
                        <option value="unlimited">♾️ Unlimited (Until Stopped)</option>
                    </select>
                </div>
                <div class="form-group" id="durationGroup">
                    <label for="duration">Duration (min) <small style="color: #999; font-weight: normal;">(max: 7 days)</small></label>
                    <input
                        type="number"
                        id="duration"
                        min="1"
                        max="10080"
                        value="5"
                        title="Enter duration in minutes. Max: 10,080 min (7 days) • 540 min = 9 hours"
                        placeholder="e.g., 540 for 9hrs"
                    >
                </div>
                <div class="form-group">
                    <label for="deviceMode">Device Mode</label>
                    <select id="deviceMode" required>
                        <option value="desktop" selected>🖥️ Desktop</option>
                        <option value="mobile">📱 Mobile</option>
                        <option value="tablet">📱 Tablet</option>
                        <option value="mixed">🔄 Mixed (Rotate)</option>
                    </select>
                </div>
                <button type="submit" class="btn btn-primary" id="startBtn">
                    🚀 Start Extraction
                </button>
            </form>
        </div>

        <div class="status-panel hidden" id="statusPanel">
            <div class="status-header">
                <h3>Extraction Status</h3>
                <div>
                    <span class="status-badge" id="statusBadge">Idle</span>
                    <button class="btn btn-danger" id="stopBtn" onclick="stopExtraction()" disabled>
                        Stop
                    </button>
                </div>
            </div>
            <div style="margin-top: 15px; margin-bottom: 10px;">
                <h4 style="font-size: 16px; font-weight: 600; color: #374151; margin: 0;">📝 Live Logs</h4>
            </div>
            <div class="logs-container" id="logsContainer">
                <div>Waiting for extraction to start...</div>
            </div>
        </div>

        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-number" id="totalAds">0</div>
                <div class="stat-label">Total Ads</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="uniqueAdvertisers">0</div>
                <div class="stat-label">Unique Advertisers</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="adsWithLinks">0</div>
                <div class="stat-label">Ads with Links</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="totalSessions">0</div>
                <div class="stat-label">Total Sessions</div>
            </div>
        </div>

        <div class="ads-container">
            <div class="ads-header">
                <h3>Extracted Ads <span id="currentSessionInfo" style="font-size: 14px; color: #666;"></span></h3>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <button class="btn btn-primary" onclick="createNewSession()">
                        ➕ New Session
                    </button>
                    <select id="sessionSelector" onchange="loadSession(this.value)" style="padding: 8px; border-radius: 8px; border: 1px solid #ddd; min-width: 200px;">
                        <option value="">Current Session</option>
                    </select>
                    <button class="btn btn-success" onclick="refreshAds()">
                        🔄 Refresh
                    </button>
                    <button class="btn btn-primary" onclick="loadAllFromDatabase()" title="Load ads from database">
                        🗄️ Load DB
                    </button>
                    <button class="btn btn-success" onclick="testDatabaseHealth()" title="Test database connection and health">
                        🩺 Test DB
                    </button>
                    <div style="display: flex; gap: 5px; align-items: center;">
                        <label for="timeframeFilter" style="font-size: 12px; color: #666;">Time Filter:</label>
                        <select id="timeframeFilter" onchange="applyTimeFilter()" style="padding: 6px; border-radius: 6px; border: 1px solid #ddd; font-size: 12px;">
                            <option value="">All Time</option>
                            <option value="5">Last 5 min</option>
                            <option value="15">Last 15 min</option>
                            <option value="30">Last 30 min</option>
                            <option value="60">Last 1 hour</option>
                            <option value="180">Last 3 hours</option>
                            <option value="720">Last 12 hours</option>
                            <option value="1440">Last 24 hours</option>
                            <option value="custom">Custom Time</option>
                        </select>
                    </div>
                    <div id="customTimeControls" style="display: none; flex-direction: column; gap: 10px; background: #f8f9fa; padding: 15px; border-radius: 8px; border: 1px solid #e5e7eb; margin-top: 10px;">
                        <div style="display: flex; align-items: center; gap: 10px; font-weight: 600; color: #374151;">
                            <span id="timeFilterMode">🕒 Custom Time Range</span>
                            <span id="sessionFilterInfo" style="font-size: 12px; color: #6b7280; font-weight: normal;"></span>
                        </div>

                        <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                            <label style="font-size: 12px; color: #374151; font-weight: 500;">From:</label>
                            <input type="datetime-local" id="customTimeFrom" style="padding: 6px 8px; border-radius: 6px; border: 1px solid #d1d5db; font-size: 12px; min-width: 160px;">
                            <label style="font-size: 12px; color: #374151; font-weight: 500;">To:</label>
                            <input type="datetime-local" id="customTimeTo" style="padding: 6px 8px; border-radius: 6px; border: 1px solid #d1d5db; font-size: 12px; min-width: 160px;">
                        </div>

                        <div style="display: flex; gap: 8px; align-items: center; flex-wrap: wrap;">
                            <button onclick="applyCustomTimeFilter()" style="padding: 6px 12px; border-radius: 6px; background: #667eea; color: white; font-size: 12px; cursor: pointer; border: none; font-weight: 500;">Apply Range</button>
                            <button onclick="clearTimeFilters()" style="padding: 6px 12px; border-radius: 6px; background: #ef4444; color: white; font-size: 12px; cursor: pointer; border: none; font-weight: 500;">Clear Filters</button>

                            <div style="margin-left: 10px; padding-left: 10px; border-left: 1px solid #d1d5db;">
                                <span style="font-size: 11px; color: #6b7280; margin-right: 5px;">Quick:</span>
                                <button onclick="setQuickRange('today')" style="padding: 4px 8px; border-radius: 4px; border: 1px solid #d1d5db; background: white; font-size: 11px; cursor: pointer; margin-right: 4px;">Today</button>
                                <button onclick="setQuickRange('yesterday')" style="padding: 4px 8px; border-radius: 4px; border: 1px solid #d1d5db; background: white; font-size: 11px; cursor: pointer; margin-right: 4px;">Yesterday</button>
                                <button onclick="setQuickRange('week')" style="padding: 4px 8px; border-radius: 4px; border: 1px solid #d1d5db; background: white; font-size: 11px; cursor: pointer;">This Week</button>
                                <button onclick="setQuickRange('last24h')" style="padding: 4px 8px; border-radius: 4px; border: 1px solid #d1d5db; background: white; font-size: 11px; cursor: pointer; margin-left: 4px;">Last 24h</button>
                            </div>
                        </div>
                    </div>
                    <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                        <button class="btn btn-success" onclick="exportData('json')" style="min-width: 120px;">
                            💾 Export JSON
                        </button>
                        <button class="btn btn-success" onclick="exportData('csv')" style="min-width: 120px;">
                            📊 Export CSV
                        </button>
                        <button class="btn btn-success" onclick="exportExcel()" style="min-width: 120px;">
                            📑 Export Excel
                        </button>
                    </div>
                </div>
            </div>
            <div class="loading" id="adsLoading">
                <div class="spinner"></div>
                <p>Loading ads...</p>
            </div>
            <div class="ads-grid" id="adsGrid"></div>
        </div>
    </div>

    <script>
        let currentExtractionId = null;
        let statusCheckInterval = null;
        let adsData = [];

        // Helper function to get auth headers
        function getAuthHeaders() {
            const token = localStorage.getItem('token');
            const headers = {
                'Content-Type': 'application/json'
            };
            if (token) {
                headers['Authorization'] = `Bearer ${token}`;
            }
            return headers;
        }

        // Helper function for authenticated fetch
        async function authFetch(url, options = {}) {
            const token = localStorage.getItem('token');
            const defaultOptions = {
                credentials: 'include', // Include cookies
                headers: {
                    'Content-Type': 'application/json',
                    ...(token && { 'Authorization': `Bearer ${token}` })
                }
            };

            const mergedOptions = {
                ...defaultOptions,
                ...options,
                headers: {
                    ...defaultOptions.headers,
                    ...(options.headers || {})
                }
            };

            return fetch(url, mergedOptions);
        }

        // Logout function
        function logout() {
            authFetch('/api/auth/logout', { method: 'POST' })
                .then(() => {
                    localStorage.removeItem('token');
                    localStorage.removeItem('user');
                    window.location.href = '/login';
                });
        }

        // Real-time updates via Server-Sent Events
        let eventSource = null;

        function connectToRealTimeUpdates() {
            if (eventSource) {
                eventSource.close();
            }

            eventSource = new EventSource('/api/events');

            eventSource.onopen = function() {
                console.log('✅ SSE CONNECTION OPENED - Real-time updates connected');
                showAlert('success', 'Real-time updates connected');

                // Show real-time indicator
                const indicator = document.getElementById('realtimeIndicator');
                if (indicator) {
                    indicator.style.display = 'inline-block';
                }
            };

            eventSource.onmessage = function(event) {
                console.log('📡 SSE MESSAGE RECEIVED:', event.data);
                try {
                    const data = JSON.parse(event.data);
                    console.log('📦 Parsed SSE data:', data);
                    handleRealTimeUpdate(data);
                } catch (error) {
                    console.error('❌ Failed to parse SSE message:', error, 'Raw data:', event.data);
                }
            };

            eventSource.onerror = function(error) {
                console.error('❌ Real-time connection error:', error);
                showAlert('warning', 'Real-time connection lost - will reconnect');

                // Hide real-time indicator
                const indicator = document.getElementById('realtimeIndicator');
                if (indicator) {
                    indicator.style.display = 'none';
                }

                // Reconnect after delay
                setTimeout(() => {
                    if (eventSource.readyState === EventSource.CLOSED) {
                        connectToRealTimeUpdates();
                    }
                }, 5000);
            };
        }

        async function checkActiveExtractions() {
            try {
                console.log('🔍 [ACTIVE_CHECK] Fetching active extractions...');
                const response = await authFetch('/api/extract/active');
                const data = await response.json();

                if (data.success && data.activeExtractions.length > 0) {
                    console.log('🔄 [ACTIVE_CHECK] Found active extractions:', data.activeExtractions);

                    // Show extraction window for the first active extraction
                    const activeExtraction = data.activeExtractions[0];
                    console.log('📊 [ACTIVE_CHECK] Active extraction details:', {
                        id: activeExtraction.id,
                        sessionId: activeExtraction.sessionId,
                        sessionFile: activeExtraction.sessionFile,
                        totalAds: activeExtraction.totalAds
                    });

                    // Use the proper showExtractionWindow function to ensure all UI elements are shown
                    showExtractionWindow(activeExtraction);

                    // Load ads for the active session
                    const sessionFile = activeExtraction.sessionFile || `worker_${activeExtraction.sessionId}.json`;
                    console.log(`📂 [ACTIVE_CHECK] Will load session file: ${sessionFile}`);

                    // Update session selector to show the active session
                    const selector = document.getElementById('sessionSelector');
                    if (selector) {
                        console.log(`🔍 [ACTIVE_CHECK] Searching in ${selector.options.length} dropdown options...`);
                        let found = false;
                        // Try to find and select the matching session in the dropdown
                        for (let i = 0; i < selector.options.length; i++) {
                            console.log(`   Option ${i}: value="${selector.options[i].value}" text="${selector.options[i].text}"`);
                            if (selector.options[i].value === sessionFile ||
                                selector.options[i].value === activeExtraction.sessionId) {
                                selector.selectedIndex = i;
                                console.log(`✅ [ACTIVE_CHECK] Auto-selected option ${i}: ${selector.options[i].text}`);
                                found = true;
                                break;
                            }
                        }
                        if (!found) {
                            console.warn(`⚠️ [ACTIVE_CHECK] Session file "${sessionFile}" not found in dropdown!`);
                        }
                    } else {
                        console.error('❌ [ACTIVE_CHECK] Session selector element not found!');
                    }

                    // Load the session's ads
                    console.log(`📂 [ACTIVE_CHECK] Calling loadSession("${sessionFile}")...`);
                    await loadSession(sessionFile);
                    console.log(`✅ [ACTIVE_CHECK] loadSession completed`);

                    // Show success message
                    showAlert('info', `🔄 Reconnected to active extraction: ${activeExtraction.id}`);
                } else {
                    // No active extractions - clear any stale extraction IDs
                    console.log('✅ [ACTIVE_CHECK] No active extractions found');
                    currentExtractionId = null;
                    window.currentExtractionId = null;
                    stopStatusMonitoring();
                }
            } catch (error) {
                console.error('❌ [ACTIVE_CHECK] Failed to check active extractions:', error);
                // On error, also clear stale IDs to prevent continuous 404s
                currentExtractionId = null;
                window.currentExtractionId = null;
                stopStatusMonitoring();
            }
        }

        async function checkSessionActiveExtraction(sessionFile) {
            try {
                const response = await authFetch('/api/extract/active');
                const data = await response.json();

                if (data.success && data.activeExtractions.length > 0) {
                    // Check if any active extraction matches this session
                    const sessionId = sessionFile.replace('worker_', '').replace('.json', '');
                    const matchingExtraction = data.activeExtractions.find(ext =>
                        ext.id === sessionId ||
                        ext.sessionId === sessionId ||
                        ext.sessionFile === sessionFile
                    );

                    if (matchingExtraction) {
                        console.log('🔄 Found active extraction for session:', sessionFile, matchingExtraction);

                        // Show live extraction window
                        showExtractionWindow(matchingExtraction);

                        showAlert('info', `🔴 Live extraction detected - Session is actively running!`);
                    }
                }
            } catch (error) {
                console.error('Failed to check session active extraction:', error);
            }
        }

        function showExtractionWindow(extraction) {
            console.log('🔄 Showing extraction window for:', extraction);

            // Show status panel (the correct element for our UI)
            const statusPanel = document.getElementById('statusPanel');
            const statusBadge = document.getElementById('statusBadge');
            const stopBtn = document.getElementById('stopBtn');
            const logsContainer = document.getElementById('logsContainer');

            if (statusPanel) {
                statusPanel.classList.remove('hidden');
            }

            if (statusBadge) {
                statusBadge.textContent = extraction.status === 'resumable' ? 'Resumable' : 'Running';
                statusBadge.className = 'status-badge';
                statusBadge.style.backgroundColor = extraction.status === 'resumable' ? '#17a2b8' : '#28a745';
            }

            // Handle different extraction states
            if (extraction.status === 'resumable') {
                showResumableExtraction(extraction);
            } else if (['running', 'starting'].includes(extraction.status)) {
                // Show stop button for running extractions
                if (stopBtn) {
                    stopBtn.style.display = 'inline-block';
                    stopBtn.disabled = false;
                }

                if (logsContainer) {
                    logsContainer.innerHTML = '<div class="log-entry"><span style="color: #999; font-size: 0.8em;">[' + new Date().toLocaleTimeString() + ']</span> <span style="color: #0066cc;">🔴 Extraction is running - connecting to live logs...</span></div>';
                }

                // Store extraction ID for stop functionality
                currentExtractionId = extraction.id;
                window.currentExtractionId = extraction.id;

                // Start monitoring for real-time updates
                startStatusMonitoring();

                // Update status display
                updateExtractionStatus({
                    status: extraction.status,
                    progress: extraction.progress,
                    totalAds: extraction.totalAds,
                    logs: extraction.logs || []
                });
            }

            // Hide start button
            const startBtn = document.getElementById('startBtn');
            if (startBtn) {
                startBtn.style.display = 'none';
            }
        }

        function handleRealTimeUpdate(data) {
            console.log('📡 Real-time update received:', data.type, data);

            switch (data.type) {
                case 'connected':
                    console.log('Connected to real-time updates');
                    break;

                case 'new_ads':
                    console.log('📡 Real-time update: new_ads', data);

                    if (data.newAds && data.newAds.length > 0) {
                        console.log(`📦 Received ${data.newAds.length} new ads via SSE`);

                        // Clear "No ads found" message if it exists
                        const grid = document.getElementById('adsGrid');
                        if (grid && grid.querySelector('.no-ads')) {
                            grid.innerHTML = '';
                        }

                        // Initialize adsData if needed
                        if (!adsData) adsData = [];

                        // OPTION: Disable duplicate filtering to show all ads
                        // Set this to true to see ALL ads including duplicates
                        const SHOW_ALL_ADS = true;

                        let uniqueNewAds = [];

                        if (SHOW_ALL_ADS) {
                            // Show all ads without filtering - just add them
                            console.log(`✅ SHOW_ALL_ADS mode: Adding all ${data.newAds.length} ads without filtering`);
                            uniqueNewAds = data.newAds;
                        } else {
                            // Original duplicate filtering logic
                            const existingAdsMap = new Map();
                            adsData.forEach(ad => {
                                const key = `${ad.advertiser || ad.sponsor || ''}_${ad.headline || ad.heading || ''}_${ad.timestamp || ''}`;
                                existingAdsMap.set(key, ad);
                            });

                            // Filter out duplicates before adding
                            uniqueNewAds = data.newAds.filter(newAd => {
                                const key = `${newAd.advertiser || newAd.sponsor || ''}_${newAd.headline || newAd.heading || ''}_${newAd.timestamp || ''}`;

                                // Also check by ID if available
                                const hasId = adsData.some(existingAd =>
                                    existingAd.id && newAd.id && existingAd.id === newAd.id
                                );

                                return !existingAdsMap.has(key) && !hasId;
                            });
                        }

                        if (uniqueNewAds.length > 0) {
                            console.log(`Adding ${uniqueNewAds.length} ads to display${SHOW_ALL_ADS ? ' (all ads, no filtering)' : ` (filtered ${data.newAds.length - uniqueNewAds.length} duplicates)`}`);

                            // Add new ads
                            adsData.push(...uniqueNewAds);

                            // Redisplay all ads (including new ones)
                            displayAds(adsData);
                            updateStats(adsData);

                            showAlert('success', `🆕 ${uniqueNewAds.length} new ads found!`);
                        } else {
                            console.log('All received ads were duplicates, skipping update');
                        }
                    }

                    // Update total count if provided
                    if (data.totalAds !== undefined) {
                        updateAdCount(data.totalAds);
                    }

                    // Update session info
                    updateSessionInfo();
                    break;

                case 'status_update':
                    // Update extraction status
                    if (data.status && data.status.status) {
                        updateExtractionStatus(data.status);
                    }
                    break;

                case 'session_created':
                    // New session created - refresh session list
                    showAlert('success', `📋 Session created: ${data.sessionId}`);
                    updateSessionInfo();
                    break;

                case 'log':
                    // Log messages from extraction worker - display in UI
                    console.log(`📨 SSE LOG RECEIVED: [${data.level?.toUpperCase() || 'INFO'}] ${data.message}`);
                    addLogToUI(data.level || 'info', data.message);
                    break;
            }
        }

        function addLogToUI(level, message) {
            const logsContainer = document.getElementById('logsContainer');
            if (!logsContainer) {
                console.warn('logsContainer not found in DOM');
                return;
            }

            // Clear placeholder message on first real log
            if (logsContainer.children.length === 1 &&
                (logsContainer.textContent.includes('Waiting') ||
                 logsContainer.textContent.includes('connecting to live logs'))) {
                logsContainer.innerHTML = '';
                console.log('🧹 Cleared placeholder message from logs container');
            }

            // Create log entry with timestamp
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${level}`;

            // Style based on log level
            let color = '#333';
            let icon = '📋';
            switch (level) {
                case 'info': color = '#0066cc'; icon = '💡'; break;
                case 'warn': color = '#ff9900'; icon = '⚠️'; break;
                case 'error': color = '#cc0000'; icon = '❌'; break;
                case 'debug': color = '#666'; icon = '🔍'; break;
            }

            logEntry.innerHTML = `
                <span style="color: #999; font-size: 0.8em;">[${timestamp}]</span>
                <span style="color: ${color};">${icon} ${escapeHtml(message)}</span>
            `;

            // Add to container and scroll to bottom
            logsContainer.appendChild(logEntry);
            logsContainer.scrollTop = logsContainer.scrollHeight;

            console.log(`✅ Added log to UI: [${level}] ${message}`);

            // Limit to last 100 log entries
            const logEntries = logsContainer.querySelectorAll('.log-entry');
            if (logEntries.length > 100) {
                logEntries[0].remove();
            }
        }

        async function loadSessionAdsFromDatabase(sessionId) {
            try {
                // Query all ads for this session from database
                const response = await authFetch('/api/query/ads/query', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        filters: { sessionIds: [sessionId] },
                        sort: { field: 'timestamp', direction: 'DESC' },
                        pagination: { limit: 1000000, offset: 0 }  // 1 million for unlimited extraction
                    })
                });

                const result = await response.json();

                if (result.success) {
                    // Map database field names to frontend field names
                    const mappedAds = result.data.map(dbAd => ({
                        id: dbAd.id || dbAd.ad_id,
                        advertiser: dbAd.ad_network || dbAd.advertiser || 'Unknown',
                        headline: dbAd.heading || dbAd.headline || '',
                        body: dbAd.description || dbAd.body || '',
                        image: dbAd.image_url || dbAd.image || '',
                        link: dbAd.link_url || dbAd.link || '',
                        timestamp: dbAd.timestamp || dbAd.created_at || new Date().toISOString(),
                        containerId: dbAd.session_id
                    }));

                    // Update global adsData and display
                    adsData = mappedAds;
                    displayAds(mappedAds);

                    // Update stats
                    const uniqueAdvertisers = new Set(mappedAds.map(ad => ad.advertiser).filter(a => a && a !== 'Unknown'));
                    const adsWithLinks = mappedAds.filter(ad => ad.link).length;

                    document.getElementById('totalAds').textContent = mappedAds.length;
                    document.getElementById('uniqueAdvertisers').textContent = uniqueAdvertisers.size;
                    document.getElementById('adsWithLinks').textContent = adsWithLinks;
                }
            } catch (error) {
                console.error('Failed to load session ads from database:', error);
            }
        }

        function addNewAdsToDisplay(newAds) {
            // Prepend new ads to existing display
            const grid = document.getElementById('adsGrid');
            const existingContent = grid.innerHTML;

            // Generate HTML for new ads
            const newAdsHtml = newAds.map((ad, index) => {
                const safeAdvertiser = escapeHtml(ad.advertiser);
                const safeHeadline = escapeHtml(ad.headline);
                const safeBody = escapeHtml(ad.body);
                const safeImage = ad.image && typeof ad.image === 'string' && ad.image.trim() && !ad.image.includes('undefined') ? ad.image.trim() : '';
                const safeLink = ad.link && typeof ad.link === 'string' && ad.link.trim() ? ad.link.trim() : '';

                return `
                    <div class="ad-card new-ad" data-index="${index}" style="animation: slideInNew 0.5s ease-out;">
                        ${safeImage ?
                            `<img src="${safeImage}" alt="${safeHeadline}"
                             style="width: 100%; height: 200px; object-fit: cover; border-radius: 8px; margin-bottom: 10px;"
                             onerror="this.style.display='none'">` : ''}
                        <div class="ad-advertiser">${safeAdvertiser}</div>
                        <div class="ad-headline">${safeHeadline || 'No headline'}</div>
                        ${safeBody ? `<div class="ad-body">${safeBody}</div>` : ''}
                        <div style="display: flex; gap: 8px; margin-top: 10px; flex-wrap: wrap; ${safeLink && safeImage ? 'justify-content: space-between' : ''};">
                            ${safeLink ? `<a href="${safeLink}" target="_blank" class="ad-link">🔗 Visit Ad</a>` : ''}
                            ${safeImage ?
                                `<a onclick="downloadImage('${safeImage.replace(/'/g, "\\'")}', '${safeHeadline.replace(/'/g, "\\'")}')" class="ad-link" style="cursor: pointer; ${!safeLink ? 'margin-left: auto;' : ''}">📥 Download Image</a>` : ''}
                        </div>
                        <div style="font-size: 11px; color: #888; margin-top: 8px;">
                            ${new Date(ad.timestamp).toLocaleString()} <span style="color: #10b981; font-weight: bold;">NEW</span>
                        </div>
                    </div>
                `;
            }).join('');

            // Add new ads at the top
            grid.innerHTML = newAdsHtml + existingContent;

            // Remove animation class after animation completes
            setTimeout(() => {
                document.querySelectorAll('.new-ad').forEach(card => {
                    card.classList.remove('new-ad');
                    card.style.animation = '';
                });
            }, 500);

            // Update global adsData array
            adsData = newAds.concat(adsData);
        }

        function updateAdCount(totalAds) {
            // Update the total ads counter
            const totalAdsElement = document.getElementById('totalAds');
            if (totalAdsElement) {
                totalAdsElement.textContent = totalAds;
            }
        }

        function updateExtractionStatus(status) {
            // Update status badge and progress
            if (status.status) {
                showStatus(status.status, status.status);
            }

            if (status.progress !== undefined) {
                // Update progress display if available
                console.log(`Extraction progress: ${status.progress}%`);
            }
        }

        // Auto-refresh interval for real-time updates
        let autoRefreshInterval = null;
        const AUTO_REFRESH_INTERVAL = 5000; // 5 seconds

        function startAutoRefresh() {
            // Clear any existing interval
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
            }

            // Start periodic refresh
            autoRefreshInterval = setInterval(async () => {
                console.log('🔄 [AUTO_REFRESH] Fetching latest ads...');

                // Get current session from dropdown
                const sessionSelector = document.getElementById('sessionSelector');
                const currentSession = sessionSelector ? sessionSelector.value : '';

                try {
                    // Fetch latest ads without showing loading indicator
                    const url = currentSession ? `/api/ads?session=${currentSession}` : '/api/ads';
                    const response = await fetch(url);
                    const latestAds = await response.json();

                    console.log(`📊 [AUTO_REFRESH] Fetched ${latestAds.length} ads`);

                    // Only update if we have new data
                    if (latestAds.length > 0 && (!adsData || latestAds.length !== adsData.length)) {
                        console.log(`✨ [AUTO_REFRESH] Updating display (${adsData?.length || 0} → ${latestAds.length})`);
                        adsData = latestAds;
                        displayAds(adsData);
                        updateStats(adsData);
                    }
                } catch (error) {
                    console.warn('⚠️ [AUTO_REFRESH] Failed to fetch ads:', error.message);
                }
            }, AUTO_REFRESH_INTERVAL);

            console.log(`✅ [AUTO_REFRESH] Started auto-refresh every ${AUTO_REFRESH_INTERVAL/1000}s`);
        }

        function stopAutoRefresh() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
                console.log('🛑 [AUTO_REFRESH] Stopped auto-refresh');
            }
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('🚀 [PAGE_LOAD] Initializing page...');

            // Load stats (non-blocking)
            loadStats();

            // Connect to real-time updates FIRST
            connectToRealTimeUpdates();

            // Load sessions FIRST and WAIT for it to complete
            // This is critical so the dropdown is populated before we try to select
            console.log('📋 [PAGE_LOAD] Loading sessions...');
            await loadSessions();
            console.log('✅ [PAGE_LOAD] Sessions loaded');

            // Check for active extractions BEFORE loading ads
            // This ensures we load the active session's ads, not "All Sessions"
            console.log('🔍 [PAGE_LOAD] Checking for active extractions...');
            await checkActiveExtractions();

            // If no active extraction was found, load current session ads
            if (!currentExtractionId) {
                console.log('📂 [PAGE_LOAD] No active extraction - loading current session ads');
                await loadAds(''); // Load current session
            } else {
                console.log('✅ [PAGE_LOAD] Active extraction found - ads already loaded');
            }

            updateSessionInfo();

            // Start auto-refresh for real-time updates
            startAutoRefresh();

            // Set up form submission
            document.getElementById('extractionForm').addEventListener('submit', startExtraction);

            console.log('✅ [PAGE_LOAD] Page initialization complete with auto-refresh enabled');
        });

        async function startExtraction(e) {
            e.preventDefault();

            const url = document.getElementById('url').value;
            const duration = document.getElementById('duration').value;
            const deviceMode = document.getElementById('deviceMode').value;
            const extractionMode = document.getElementById('extractionMode').value;

            // Disable start button
            document.getElementById('startBtn').disabled = true;

            try {
                // First create a new session
                const sessionResponse = await authFetch('/api/sessions/new', {
                    method: 'POST'
                });

                if (!sessionResponse.ok) {
                    throw new Error('Failed to create new session');
                }

                const sessionData = await sessionResponse.json();
                showAlert('success', `New session created: ${sessionData.sessionId || 'New Session'}`);

                // Clear ads grid to show fresh start
                document.getElementById('adsGrid').innerHTML = '<p style="text-align: center; padding: 20px;">New session started - waiting for ads...</p>';

                // Immediately update UI with new session
                document.getElementById('sessionSelector').value = '';
                await loadSessions();
                await loadAds();
                await updateSessionInfo();

                // Add a visual flash to the session info
                const sessionInfo = document.getElementById('currentSessionInfo');
                sessionInfo.style.transition = 'all 0.3s';
                sessionInfo.style.color = '#10b981';
                sessionInfo.style.fontWeight = 'bold';
                setTimeout(() => {
                    sessionInfo.style.color = '#666';
                    sessionInfo.style.fontWeight = 'normal';
                }, 2000);

                // Now start extraction
                const response = await authFetch('/api/extract/start', {
                    method: 'POST',
                    body: JSON.stringify({ url, duration, deviceMode, extractionMode })
                });

                const data = await response.json();

                if (response.ok) {
                    currentExtractionId = data.extractionId;
                    showStatus('running', `Extraction started (ID: ${currentExtractionId})`);
                    document.getElementById('statusPanel').classList.remove('hidden');
                    document.getElementById('stopBtn').disabled = false;

                    // Initialize logs container
                    const logsContainer = document.getElementById('logsContainer');
                    if (logsContainer) {
                        logsContainer.innerHTML = '<div class="log-entry"><span style="color: #999; font-size: 0.8em;">[' + new Date().toLocaleTimeString() + ']</span> <span style="color: #0066cc;">🔴 Extraction is running - connecting to live logs...</span></div>';
                    }

                    // Start monitoring status
                    startStatusMonitoring();

                    // Start auto-refresh for ads
                    startAutoRefresh();
                } else {
                    showAlert('error', data.error || 'Failed to start extraction');
                    document.getElementById('startBtn').disabled = false;
                }
            } catch (error) {
                showAlert('error', 'Network error: ' + error.message);
                document.getElementById('startBtn').disabled = false;
            }
        }

        async function stopExtraction() {
            if (!currentExtractionId) return;

            try {
                const response = await authFetch(`/api/extract/stop/${currentExtractionId}`, {
                    method: 'POST'
                });

                // Handle 404 - extraction not found (already stopped)
                if (response.status === 404) {
                    showAlert('warning', 'Extraction not found - may have already stopped');
                    currentExtractionId = null;
                    window.currentExtractionId = null;
                    stopStatusMonitoring();
                    showStatus('idle', 'No active extraction');
                    document.getElementById('stopBtn').disabled = true;
                    return;
                }

                const data = await response.json();

                if (response.ok) {
                    showStatus('stopped', 'Extraction stopped');
                    stopStatusMonitoring();
                    currentExtractionId = null;
                    window.currentExtractionId = null;

                    // Final refresh to get all ads
                    await loadAds();
                    await loadStats();
                    await loadSessions();
                    updateSessionInfo();

                    showAlert('success', 'Extraction stopped successfully');
                } else {
                    showAlert('error', data.error || 'Failed to stop extraction');
                }
            } catch (error) {
                showAlert('error', 'Network error: ' + error.message);
            }
        }

        function startStatusMonitoring() {
            if (statusCheckInterval) clearInterval(statusCheckInterval);

            // Immediately refresh session display when extraction starts
            setTimeout(() => {
                loadAds(''); // Load current session
                loadStats();
            }, 1000); // Give worker a moment to create session

            statusCheckInterval = setInterval(async () => {
                if (!currentExtractionId) return;

                try {
                    const response = await fetch(`/api/extract/status/${currentExtractionId}`);

                    // If extraction not found (404), clear it and stop polling
                    if (response.status === 404) {
                        console.log('Extraction not found (404), clearing tracking...');
                        currentExtractionId = null;
                        window.currentExtractionId = null;
                        stopStatusMonitoring();
                        showStatus('idle', 'No active extraction');
                        document.getElementById('stopBtn').disabled = true;
                        return;
                    }

                    const data = await response.json();

                    if (response.ok) {
                        updateStatus(data);

                        // Refresh current session display during extraction
                        if (data.status === 'running' && data.sessionFile) {
                            loadAds(''); // Load current session
                        }

                        if (data.status !== 'running') {
                            stopStatusMonitoring();
                            loadAds(); // Refresh ads when extraction completes
                            loadStats();
                        }
                    }
                } catch (error) {
                    console.error('Status check failed:', error);
                }
            }, 2000); // Check every 2 seconds
        }

        function stopStatusMonitoring() {
            if (statusCheckInterval) {
                clearInterval(statusCheckInterval);
                statusCheckInterval = null;
            }
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
        }

        function updateStatus(statusData) {
            showStatus(statusData.status, `Status: ${statusData.status}`);

            // Update logs
            if (statusData.logs && statusData.logs.length > 0) {
                const logsContainer = document.getElementById('logsContainer');
                logsContainer.innerHTML = statusData.logs.map(log => {
                    // Handle different log formats
                    if (typeof log === 'string') {
                        return `<div style="font-family: monospace; font-size: 12px; margin: 2px 0; color: #333;">${escapeHtml(log)}</div>`;
                    } else if (typeof log === 'object' && log !== null) {
                        // Handle structured log objects
                        const timestamp = log.timestamp ? new Date(log.timestamp).toLocaleTimeString() : '';
                        const message = log.message || log.msg || JSON.stringify(log);
                        const level = log.level || 'info';

                        const levelColors = {
                            'error': '#dc3545',
                            'warn': '#fd7e14',
                            'info': '#0dcaf0',
                            'debug': '#6c757d'
                        };

                        const color = levelColors[level] || '#333';

                        return `<div style="font-family: monospace; font-size: 12px; margin: 2px 0; color: ${color};">
                            ${timestamp ? `<span style="color: #6c757d;">[${timestamp}]</span> ` : ''}
                            <span style="color: ${color}; font-weight: bold;">[${level.toUpperCase()}]</span>
                            ${escapeHtml(message)}
                        </div>`;
                    } else {
                        return `<div style="font-family: monospace; font-size: 12px; margin: 2px 0; color: #dc3545;">Invalid log entry: ${typeof log}</div>`;
                    }
                }).join('');
                logsContainer.scrollTop = logsContainer.scrollHeight;
            }
        }

        function showStatus(status, message) {
            const badge = document.getElementById('statusBadge');
            badge.textContent = message || status;
            badge.className = 'status-badge status-' + status;
        }

        async function loadAds(sessionFile = '') {
            document.getElementById('adsLoading').classList.add('active');

            try {
                const url = sessionFile ? `/api/ads?session=${sessionFile}` : '/api/ads';
                const response = await fetch(url);
                adsData = await response.json();
                console.log(`Loaded ${adsData.length} ads from ${sessionFile || 'current session'}`);
                displayAds(adsData);
            } catch (error) {
                console.error('Failed to load ads:', error);
                showAlert('error', 'Failed to load ads');
            } finally {
                document.getElementById('adsLoading').classList.remove('active');
            }
        }

        async function loadSessions() {
            try {
                console.log('🔄 Loading sessions from files and database...');

                // Load sessions from both JSON files and database
                const [fileResponse, dbResponse] = await Promise.all([
                    fetch('/api/sessions/list'),
                    fetch('/api/query/sessions').catch(() => ({ ok: false }))
                ]);

                const fileSessions = await fileResponse.json();
                let dbSessions = [];
                if (dbResponse.ok) {
                    const dbData = await dbResponse.json();
                    dbSessions = dbData.data || [];
                    console.log(`📊 Found ${dbSessions.length} database sessions`);
                } else {
                    console.warn('⚠️ Could not load database sessions');
                }

                const selector = document.getElementById('sessionSelector');
                selector.innerHTML = '<option value="">All Sessions</option>';

                // Add database sessions first (if available)
                if (dbSessions.length > 0) {
                    const dbGroup = document.createElement('optgroup');
                    dbGroup.label = '📊 Database Sessions';

                    dbSessions.forEach(session => {
                        const option = document.createElement('option');
                        option.value = session.session_id;
                        option.dataset.source = 'database';
                        const date = new Date(session.start_time).toLocaleString();
                        const status = session.status === 'active' ? '🟢' : '';
                        option.textContent = `${status} ${date} (${session.total_ads || 0} ads)`;
                        dbGroup.appendChild(option);
                        console.log(`  📋 Added DB session: ${session.session_id} (${session.total_ads || 0} ads)`);
                    });

                    selector.appendChild(dbGroup);
                }

                // Add file sessions
                const fileGroup = document.createElement('optgroup');
                fileGroup.label = '📁 Recent File Sessions';

                // Get current session to mark it
                const currentResponse = await authFetch('/api/sessions/current');
                let currentSessionFile = null;
                if (currentResponse.ok) {
                    const currentSession = await currentResponse.json();
                    if (currentSession) {
                        currentSessionFile = currentSession.sessionFile;
                    }
                }

                // Get active extractions to mark them
                const activeResponse = await authFetch('/api/extract/active');
                let activeExtractions = [];
                if (activeResponse.ok) {
                    const activeData = await activeResponse.json();
                    if (activeData.success) {
                        activeExtractions = activeData.activeExtractions;
                    }
                }

                fileSessions.forEach(session => {
                    const date = new Date(session.timestamp);
                    const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
                    const option = document.createElement('option');
                    option.value = session.file;

                    // Check if this session is currently active
                    const sessionId = session.file.replace('worker_', '').replace('.json', '');
                    const isActive = activeExtractions.some(ext =>
                        ext.id === sessionId ||
                        ext.sessionId === sessionId ||
                        ext.sessionFile === session.file
                    );

                    const isCurrent = session.file === currentSessionFile ? ' ⭐' : '';
                    const activeIndicator = isActive ? ' 🔴 LIVE' : '';

                    option.textContent = `${dateStr} (${session.totalAds || 0} ads)${isCurrent}${activeIndicator}`;

                    // Style active sessions differently
                    if (isActive) {
                        option.style.color = '#dc2626';
                        option.style.fontWeight = 'bold';
                    }

                    fileGroup.appendChild(option);
                });

                // Append file group if it has options
                if (fileGroup.children.length > 0) {
                    selector.appendChild(fileGroup);
                }
            } catch (error) {
                console.error('Failed to load sessions:', error);
            }
        }

        async function loadSession(sessionFile) {
            if (sessionFile) {
                // Switch to selected session
                try {
                    const response = await authFetch('/api/sessions/switch', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ sessionFile })
                    });

                    if (response.ok) {
                        await loadAds(sessionFile);
                        updateSessionInfo();
                        updateSessionFilterInfo(); // Update filter info when session changes

                        // Check if this session has active extractions
                        await checkSessionActiveExtraction(sessionFile);

                        showAlert('success', 'Switched to session: ' + sessionFile);
                    } else {
                        showAlert('error', 'Failed to switch session');
                    }
                } catch (error) {
                    showAlert('error', 'Failed to switch session: ' + error.message);
                }
            } else {
                // Load current session
                await loadAds('');
                updateSessionInfo();
                updateSessionFilterInfo(); // Update filter info when session changes

                // IMPORTANT: Check for active extractions when loading current session
                await checkActiveExtractions();
            }
        }

        function displayAds(ads) {
            const grid = document.getElementById('adsGrid');

            console.log('displayAds called with:', ads ? `${ads.length} ads` : 'no ads'); // Better debug log

            // Clear loading state
            const loadingElement = document.getElementById('adsLoading');
            if (loadingElement) {
                loadingElement.classList.remove('active');
            }

            if (!grid) {
                console.error('Ads grid element not found!');
                return;
            }

            if (!ads || ads.length === 0) {
                grid.innerHTML = '<p style="text-align: center; padding: 40px; color: #666;">No ads found. Start an extraction or click "Load DB" to load from database.</p>';
                updateStats([]); // Update stats with empty array
                return;
            }

            // Handle different data structures and normalize
            let processedAds = ads;

            // If ads is a string, try to parse it
            if (typeof ads === 'string') {
                try {
                    processedAds = JSON.parse(ads);
                } catch (e) {
                    console.error('Failed to parse ads string:', e);
                    grid.innerHTML = '<p>Error: Invalid ads data format</p>';
                    return;
                }
            }

            // Ensure we have an array
            if (!Array.isArray(processedAds)) {
                console.error('Ads is not an array:', processedAds);
                grid.innerHTML = '<p>Error: Ads data is not in the expected format</p>';
                return;
            }

            // Filter out invalid ads and normalize field names
            const validAds = processedAds.filter(ad => {
                if (!ad || typeof ad !== 'object') return false;

                // Normalize field names from different sources
                const normalized = {
                    advertiser: ad.advertiser || ad.sponsor || 'Unknown',
                    headline: ad.headline || ad.heading || ad.title || '',
                    body: ad.body || ad.description || '',
                    image: ad.image || ad.imageUrl || ad.img || '',
                    link: ad.link || ad.linkUrl || ad.url || '',
                    timestamp: ad.timestamp || new Date().toISOString()
                };

                // Only include ads with meaningful content
                return normalized.advertiser !== 'Protected Ad' &&
                       (normalized.headline || normalized.body);
            }).map(ad => ({
                advertiser: ad.advertiser || ad.sponsor || 'Unknown',
                headline: ad.headline || ad.heading || ad.title || '',
                body: ad.body || ad.description || '',
                image: ad.image || ad.imageUrl || ad.img || '',
                link: ad.link || ad.linkUrl || ad.url || '',
                timestamp: ad.timestamp || new Date().toISOString()
            }));

            if (validAds.length === 0) {
                grid.innerHTML = '<p>No valid ads to display. Start a new extraction.</p>';
                return;
            }

            try {
                grid.innerHTML = validAds.map((ad, index) => {
                    // Safely escape all fields
                    const safeAdvertiser = escapeHtml(ad.advertiser);
                    const safeHeadline = escapeHtml(ad.headline);
                    const safeBody = escapeHtml(ad.body);
                    const safeImage = ad.image && typeof ad.image === 'string' && ad.image.trim() && !ad.image.includes('undefined') ? ad.image.trim() : '';
                    const safeLink = ad.link && typeof ad.link === 'string' && ad.link.trim() ? ad.link.trim() : '';

                    return `
                        <div class="ad-card" data-index="${index}">
                            ${safeImage ?
                                `<img src="${safeImage}" alt="${safeHeadline}"
                                 style="width: 100%; height: 200px; object-fit: cover; border-radius: 8px; margin-bottom: 10px;"
                                 onerror="this.style.display='none'">` : ''}
                            <div class="ad-advertiser">${safeAdvertiser}</div>
                            <div class="ad-headline">${safeHeadline || 'No headline'}</div>
                            ${safeBody ? `<div class="ad-body">${safeBody}</div>` : ''}
                            <div style="display: flex; gap: 8px; margin-top: 10px; flex-wrap: wrap; ${safeLink && safeImage ? 'justify-content: space-between' : ''};">
                                ${safeLink ? `<a href="${safeLink}" target="_blank" class="ad-link">🔗 Visit Ad</a>` : ''}
                                ${safeImage ?
                                    `<a onclick="downloadImage('${safeImage.replace(/'/g, "\\'")}', '${safeHeadline.replace(/'/g, "\\'")}')" class="ad-link" style="cursor: pointer; ${!safeLink ? 'margin-left: auto;' : ''}">📥 Download Image</a>` : ''}
                            </div>
                            <div style="font-size: 11px; color: #888; margin-top: 8px;">
                                ${new Date(ad.timestamp).toLocaleString()}
                            </div>
                        </div>
                    `;
                }).join('');
            } catch (error) {
                console.error('Error rendering ads:', error);
                grid.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #ff6b6b;">
                        <h3>Error Displaying Ads</h3>
                        <p>There was an error rendering the ads. Check the console for details.</p>
                        <button onclick="location.reload()" style="margin-top: 10px; padding: 8px 16px; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer;">Reload Page</button>
                    </div>
                `;
            }
        }

        async function loadStats() {
            try {
                const [adsResponse, sessionsResponse] = await Promise.all([
                    fetch('/api/ads'),
                    fetch('/api/sessions')
                ]);

                const ads = await adsResponse.json();
                const sessions = await sessionsResponse.json();

                document.getElementById('totalAds').textContent = ads.length;
                document.getElementById('uniqueAdvertisers').textContent =
                    new Set(ads.map(ad => ad.advertiser).filter(a => a)).size;
                document.getElementById('adsWithLinks').textContent =
                    ads.filter(ad => ad.link).length;
                document.getElementById('totalSessions').textContent = sessions.length;
            } catch (error) {
                console.error('Failed to load stats:', error);
            }
        }

        // Update stats from ads array
        function updateStats(ads) {
            if (!ads || !Array.isArray(ads)) return;

            const uniqueAdvertisers = new Set(ads.map(ad =>
                ad.advertiser || ad.ad_network || 'Unknown'
            ).filter(a => a && a !== 'Unknown'));

            const adsWithLinks = ads.filter(ad => ad.link || ad.link_url).length;

            document.getElementById('totalAds').textContent = ads.length;
            document.getElementById('uniqueAdvertisers').textContent = uniqueAdvertisers.size;
            document.getElementById('adsWithLinks').textContent = adsWithLinks;
        }

        async function createNewSession() {
            try {
                const response = await authFetch('/api/sessions/new', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    showAlert('success', 'New session created successfully');
                    // Reset the session selector to current session
                    document.getElementById('sessionSelector').value = '';
                    // Reload everything with the new session
                    await loadAds();
                    await loadSessions();
                    await loadStats();
                    updateSessionInfo();
                } else {
                    showAlert('error', data.error || 'Failed to create new session');
                }
            } catch (error) {
                showAlert('error', 'Failed to create new session: ' + error.message);
            }
        }

        async function refreshAds() {
            console.log('🔄 Refreshing ads...');
            document.getElementById('adsLoading').classList.add('active');

            try {
                // Get the current session selector value
                const sessionSelector = document.getElementById('sessionSelector');
                let sessionToLoad = sessionSelector ? sessionSelector.value : '';

                // Clear existing seenAdIds to ensure fresh state
                seenAdIds.clear();

                // If "Current Session" is selected or nothing is selected
                if (!sessionToLoad || sessionToLoad === '' || sessionToLoad === 'current') {
                    // Check for active extraction first
                    const activeResponse = await authFetch('/api/extract/active');
                    if (activeResponse.ok) {
                        const activeData = await activeResponse.json();
                        if (activeData.success && activeData.activeExtractions && activeData.activeExtractions.length > 0) {
                            const activeExtraction = activeData.activeExtractions[0];
                            if (activeExtraction.sessionFile) {
                                sessionToLoad = activeExtraction.sessionFile;
                                console.log('Active extraction found, loading session:', sessionToLoad);
                            }
                        }
                    }

                    // If still no session, try to get current session
                    if (!sessionToLoad) {
                        const currentSessionResponse = await authFetch('/api/sessions/current');
                        if (currentSessionResponse.ok) {
                            const currentSessionData = await currentSessionResponse.json();
                            if (currentSessionData && currentSessionData.sessionFile) {
                                sessionToLoad = currentSessionData.sessionFile;
                                console.log('Loading current session:', sessionToLoad);
                            }
                        }
                    }
                }

                // Build the URL with cache buster
                let url = '/api/ads';
                if (sessionToLoad && sessionToLoad !== 'current') {
                    url = `/api/ads?session=${sessionToLoad}&t=${Date.now()}`;
                } else {
                    url = `/api/ads?t=${Date.now()}`;
                }

                console.log('Fetching ads from:', url);

                // Fetch the ads
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const newAdsData = await response.json();
                console.log(`Received ${newAdsData.length} ads from server`);

                // Clear and update the global adsData
                adsData = [];

                // Remove duplicates based on ID and content
                const uniqueAdsMap = new Map();
                newAdsData.forEach(ad => {
                    // Create unique key
                    const key = ad.id || `${ad.advertiser}_${ad.headline}_${ad.timestamp}`;
                    if (!uniqueAdsMap.has(key)) {
                        uniqueAdsMap.set(key, ad);
                    }
                });

                adsData = Array.from(uniqueAdsMap.values());
                console.log(`Filtered to ${adsData.length} unique ads`);

                // Force display update
                if (adsData && adsData.length > 0) {
                    displayAds(adsData);
                    updateStats(adsData);
                    showAlert('success', `✅ Refreshed - ${adsData.length} ads loaded`);
                } else {
                    // If no ads, show empty state
                    const adsGrid = document.getElementById('adsGrid');
                    if (adsGrid) {
                        adsGrid.innerHTML = '<p style="text-align: center; padding: 40px; color: #666;">No ads found. Start a new extraction or load from database.</p>';
                    }
                    showAlert('info', 'No ads found in current session');
                }

                // Update other UI elements
                await loadStats();
                await loadSessions();
                updateSessionInfo();

            } catch (error) {
                console.error('Failed to refresh ads:', error);
                showAlert('error', `Failed to refresh: ${error.message}`);

                // Try to recover by loading from database
                console.log('Attempting to load from database as fallback...');
                loadFromDatabase();
            } finally {
                document.getElementById('adsLoading').classList.remove('active');
            }
        }

        async function refreshNewAds() {
            document.getElementById('adsLoading').classList.add('active');

            try {
                const sessionSelector = document.getElementById('sessionSelector');
                const sessionFile = sessionSelector.value;
                const url = sessionFile ? `/api/ads?session=${sessionFile}&refresh=true` : '/api/ads?refresh=true';
                const response = await fetch(url);
                adsData = await response.json();
                console.log(`Loaded ${adsData.length} new ads from last 5 minutes`);
                displayAds(adsData);
                showAlert('info', `Showing ${adsData.length} ads from last 5 minutes`);
            } catch (error) {
                console.error('Failed to load new ads:', error);
                showAlert('error', 'Failed to load new ads');
            } finally {
                document.getElementById('adsLoading').classList.remove('active');
            }
        }

        async function testDatabaseHealth() {
            console.log('🩺 Testing database health...');

            try {
                const response = await authFetch('/api/query/health');
                const result = await response.json();

                console.log('📊 Database health results:', result);

                if (result.success && result.connected) {
                    const stats = result.stats;
                    const message = `✅ Database Connected!\n\nStats:\n• Total Ads: ${stats.totalAds}\n• Total Sessions: ${stats.totalSessions}\n• Recent Ads: ${stats.recentAds}\n\nSessions in DB: ${result.sessions.map(s => s.session_id).join(', ') || 'None'}`;
                    alert(message);

                    // Also log sample data
                    if (result.recentAds && result.recentAds.length > 0) {
                        console.log('📦 Sample ads from database:', result.recentAds);
                    }
                    if (result.sessions && result.sessions.length > 0) {
                        console.log('📋 Sessions in database:', result.sessions);
                    }
                } else {
                    alert(`❌ Database Connection Failed!\n\nError: ${result.error || 'Unknown error'}`);
                }
            } catch (error) {
                console.error('🩺 Database health test failed:', error);
                alert(`❌ Database Test Failed!\n\nError: ${error.message}`);
            }
        }

        async function loadAllFromDatabase() {
            console.log('Loading ads from database...');
            document.getElementById('adsLoading').classList.add('active');

            try {
                // Check if a session is selected
                const sessionSelector = document.getElementById('sessionSelector');
                const selectedSession = sessionSelector ? sessionSelector.value : '';
                console.log('Selected session:', selectedSession);

                // Build filters based on selection
                const filters = {};
                if (selectedSession) {
                    // Check if it's a database session or file session
                    const selectedOption = sessionSelector.options[sessionSelector.selectedIndex];
                    const isDbSession = selectedOption && selectedOption.dataset.source === 'database';

                    if (isDbSession || selectedSession.includes('T')) {
                        // Database session ID format
                        filters.sessionIds = [selectedSession];
                    } else {
                        // File session - extract timestamp from filename
                        const sessionId = selectedSession.replace('worker_', '').replace('.json', '');
                        filters.sessionIds = [sessionId];
                    }
                }
                console.log('Filters:', filters);

                // Query ads from database
                const response = await authFetch('/api/query/ads/query', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        filters: filters,
                        sort: { field: 'timestamp', direction: 'DESC' },
                        pagination: { limit: 1000000, offset: 0 }  // NO LIMIT - Request up to 1 million ads
                    })
                });

                console.log('Response status:', response.status);
                const result = await response.json();
                console.log('Result:', result);

                if (result.success) {
                    console.log('Raw data from database:', result.data.slice(0, 2)); // Log first 2 items for debugging

                    if (result.data && result.data.length > 0) {
                        // Map database field names to frontend field names
                        const mappedAds = result.data.map(dbAd => ({
                            id: dbAd.id || dbAd.ad_id,
                            advertiser: dbAd.ad_network || dbAd.advertiser || 'Unknown',
                            headline: dbAd.heading || dbAd.headline || '',
                            body: dbAd.description || dbAd.body || '',
                            image: dbAd.image_url || dbAd.image || '',
                            link: dbAd.link_url || dbAd.link || '',
                            timestamp: dbAd.timestamp || dbAd.created_at || new Date().toISOString(),
                            // Keep original fields for reference
                            containerId: dbAd.session_id,
                            iframeSize: dbAd.width && dbAd.height ? `${dbAd.width}x${dbAd.height}` : ''
                        }));

                        console.log('Mapped ads:', mappedAds.slice(0, 2)); // Log first 2 mapped items

                        adsData = mappedAds;
                        displayAds(mappedAds);

                        // Update stats properly
                        const uniqueAdvertisers = new Set(mappedAds.map(ad => ad.advertiser).filter(a => a && a !== 'Unknown'));
                        const adsWithLinks = mappedAds.filter(ad => ad.link).length;

                        document.getElementById('totalAds').textContent = mappedAds.length;
                        document.getElementById('uniqueAdvertisers').textContent = uniqueAdvertisers.size;
                        document.getElementById('adsWithLinks').textContent = adsWithLinks;

                        // Update session info to show database mode
                        if (selectedSession) {
                            document.getElementById('currentSessionInfo').textContent =
                                `(Database: Session ${selectedSession.slice(-8)} - ${mappedAds.length} ads)`;
                        } else {
                            document.getElementById('currentSessionInfo').textContent =
                                `(Database: All Sessions - ${mappedAds.length} total ads)`;
                        }

                        showAlert('success', `Loaded ${mappedAds.length} ads from database`);
                    } else {
                        document.getElementById('adsGrid').innerHTML = '<p style="text-align: center; padding: 40px; color: #666;">No ads found in database for the selected criteria.</p>';

                        if (selectedSession) {
                            showAlert('warning', `No ads found for session ${selectedSession.slice(-8)}`);
                        } else {
                            showAlert('warning', 'No ads found in database');
                        }
                    }
                } else {
                    console.error('Database query failed:', result);
                    showAlert('error', result.error || result.message || 'Failed to load ads from database');
                }
            } catch (error) {
                console.error('Failed to load all ads from database:', error);
                showAlert('error', 'Failed to load ads from database: ' + error.message);
            } finally {
                document.getElementById('adsLoading').classList.remove('active');
            }
        }

        async function updateSessionInfo() {
            try {
                const response = await authFetch('/api/sessions/current');
                if (response.ok) {
                    const session = await response.json();
                    if (session) {
                        const date = new Date(session.timestamp);
                        const timeStr = date.toLocaleTimeString();
                        const dateStr = date.toLocaleDateString();

                        // Also get current ads count
                        const adsResponse = await authFetch('/api/ads');
                        const ads = await adsResponse.json();
                        const adsCount = ads ? ads.length : 0;

                        document.getElementById('currentSessionInfo').textContent =
                            `(Session: ${dateStr} ${timeStr} | ${adsCount} ads)`;
                    } else {
                        document.getElementById('currentSessionInfo').textContent = '';
                    }
                }
            } catch (error) {
                console.error('Failed to update session info:', error);
            }
        }

        async function exportData(format) {
            try {
                // Check if we have ads to export
                if (!adsData || adsData.length === 0) {
                    showAlert('warning', 'No ads to export. Load a session or database first.');
                    return;
                }

                let filename = 'newsbreak_ads';

                // Get current session info
                const sessionSelector = document.getElementById('sessionSelector');
                if (sessionSelector && sessionSelector.value) {
                    filename = `session_${sessionSelector.value}`;
                }

                // Add timestamp to filename
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                filename += `_${timestamp}`;

                // Create blob based on format
                let blob;
                if (format === 'json') {
                    blob = new Blob([JSON.stringify(adsData, null, 2)], { type: 'application/json' });
                } else if (format === 'csv') {
                    const csv = convertToCSV(adsData);
                    blob = new Blob([csv], { type: 'text/csv' });
                }

                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${filename}.${format}`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);

                showAlert('success', `Exported ${adsData.length} ads as ${format.toUpperCase()}`);
            } catch (error) {
                showAlert('error', 'Export failed: ' + error.message);
            }
        }

        function convertToCSV(ads) {
            if (!ads || ads.length === 0) return '';

            const headers = ['Timestamp', 'Advertiser', 'Headline', 'Description', 'Link', 'Image'];
            const rows = ads.map(ad => [
                ad.timestamp || '',
                ad.advertiser || ad.ad_network || '',
                ad.headline || ad.heading || '',
                ad.body || ad.description || '',
                ad.link || ad.link_url || '',
                ad.image || ad.image_url || ''
            ]);

            // Escape CSV values
            const escapeCSV = (val) => {
                if (val === null || val === undefined) return '';
                const str = String(val);
                if (str.includes(',') || str.includes('"') || str.includes('\n')) {
                    return `"${str.replace(/"/g, '""')}"`;
                }
                return str;
            };

            const csvContent = [
                headers.join(','),
                ...rows.map(row => row.map(escapeCSV).join(','))
            ].join('\n');

            return csvContent;
        }

        function exportExcel() {
            if (!adsData || adsData.length === 0) {
                showAlert('error', 'No data to export');
                return;
            }

            // Prepare data with proper field names
            const excelData = adsData.map(ad => ({
                'Timestamp': ad.timestamp || '',
                'Advertiser': ad.advertiser || ad.ad_network || '',
                'Headline': ad.headline || ad.heading || '',
                'Description': ad.body || ad.description || '',
                'Link': ad.link || ad.link_url || '',
                'Image': ad.image || ad.image_url || ''
            }));

            const ws = XLSX.utils.json_to_sheet(excelData);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, 'Ads');

            // Generate filename
            let filename = 'newsbreak_ads';
            const sessionSelector = document.getElementById('sessionSelector');
            if (sessionSelector && sessionSelector.value) {
                filename = `session_${sessionSelector.value}`;
            }
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            filename += `_${timestamp}.xlsx`;

            XLSX.writeFile(wb, filename);

            showAlert('success', `Exported ${adsData.length} ads as Excel`);
        }

        function showAlert(type, message) {
            const alertDiv = document.createElement('div');
            alertDiv.className = `alert alert-${type}`;
            alertDiv.textContent = message;

            document.querySelector('.header').appendChild(alertDiv);

            setTimeout(() => {
                alertDiv.remove();
            }, 5000);
        }

        function escapeHtml(str) {
            if (str === null || str === undefined) return '';
            if (typeof str === 'object') {
                return JSON.stringify(str);
            }
            const div = document.createElement('div');
            div.textContent = String(str);
            return div.innerHTML;
        }

        // Toggle duration field based on extraction mode
        function toggleDurationField() {
            const extractionMode = document.getElementById('extractionMode').value;
            const durationGroup = document.getElementById('durationGroup');
            const durationInput = document.getElementById('duration');

            if (extractionMode === 'unlimited') {
                durationGroup.style.display = 'none';
                durationInput.removeAttribute('required');
            } else {
                durationGroup.style.display = 'block';
                durationInput.setAttribute('required', 'required');
            }
        }

        // Apply time filter to current ads
        async function applyTimeFilter() {
            const timeframe = document.getElementById('timeframeFilter').value;
            const customTimeControls = document.getElementById('customTimeControls');

            // Show/hide custom time controls
            if (timeframe === 'custom') {
                customTimeControls.style.display = 'flex';
                updateSessionFilterInfo();
                return;
            } else {
                customTimeControls.style.display = 'none';
            }

            try {
                let url = '/api/ads';
                const currentSession = document.getElementById('sessionSelector').value;

                const params = new URLSearchParams();
                if (currentSession) {
                    params.append('session', currentSession);
                }
                if (timeframe) {
                    params.append('timeframe', timeframe);
                }

                if (params.toString()) {
                    url += '?' + params.toString();
                }

                const response = await fetch(url);
                const ads = await response.json();

                adsData = ads;
                displayAds(ads);
                updateStats(ads);

                const filterText = timeframe ?
                    `Showing ads from last ${timeframe} minutes` :
                    'Showing all ads';

                showAlert('info', filterText);
            } catch (error) {
                console.error('Failed to apply time filter:', error);
                showAlert('error', 'Failed to filter ads');
            }
        }

        // Apply custom time filter with date range
        async function applyCustomTimeFilter() {
            const fromDate = document.getElementById('customTimeFrom').value;
            const toDate = document.getElementById('customTimeTo').value;

            if (!fromDate || !toDate) {
                showAlert('error', 'Please select both start and end dates');
                return;
            }

            const fromTime = new Date(fromDate);
            const toTime = new Date(toDate);

            if (fromTime >= toTime) {
                showAlert('error', 'Start date must be before end date');
                return;
            }

            document.getElementById('adsLoading').classList.add('active');

            try {
                const sessionSelector = document.getElementById('sessionSelector');
                const currentSession = sessionSelector.value;

                if (currentSession) {
                    // Filter within specific session
                    await filterSessionByTimeRange(currentSession, fromTime, toTime);
                } else {
                    // Filter across all sessions/database
                    await filterAllByTimeRange(fromTime, toTime);
                }
            } catch (error) {
                console.error('Failed to apply custom time filter:', error);
                showAlert('error', 'Failed to apply time filter');
            } finally {
                document.getElementById('adsLoading').classList.remove('active');
            }
        }

        // Filter ads within a specific session by time range
        async function filterSessionByTimeRange(sessionFile, fromTime, toTime) {
            try {
                // First load the full session
                const sessionResponse = await authFetch(`/api/ads?session=${sessionFile}`);
                const sessionAds = await sessionResponse.json();

                // Filter by time range
                const filteredAds = sessionAds.filter(ad => {
                    if (!ad.timestamp) return false;
                    const adTime = new Date(ad.timestamp);
                    return adTime >= fromTime && adTime <= toTime;
                });

                adsData = filteredAds;
                displayAds(filteredAds);
                updateStats(filteredAds);

                const fromFormatted = fromTime.toLocaleString();
                const toFormatted = toTime.toLocaleString();
                const sessionName = sessionFile.replace('.json', '').replace('session_', '');

                // Update session info to show filtering
                document.getElementById('currentSessionInfo').textContent =
                    `(Session: ${sessionName} | ${filteredAds.length} ads | ${fromFormatted} to ${toFormatted})`;

                showAlert('success', `Found ${filteredAds.length} ads in session from ${fromFormatted} to ${toFormatted}`);
            } catch (error) {
                console.error('Failed to filter session by time:', error);
                showAlert('error', 'Failed to filter session by time range');
            }
        }

        // Filter all ads by time range (database query)
        async function filterAllByTimeRange(fromTime, toTime) {
            try {
                const response = await authFetch('/api/query/ads/query', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        filters: {
                            dateRange: {
                                start: fromTime.toISOString(),
                                end: toTime.toISOString()
                            }
                        },
                        sort: { field: 'timestamp', direction: 'DESC' },
                        pagination: { limit: 1000000, offset: 0 }  // 1 million for unlimited extraction
                    })
                });

                const result = await response.json();

                if (result.success) {
                    adsData = result.data;
                    displayAds(result.data);
                    updateStats(result.data);

                    const fromFormatted = fromTime.toLocaleString();
                    const toFormatted = toTime.toLocaleString();

                    // Update session info to show database filtering
                    document.getElementById('currentSessionInfo').textContent =
                        `(Database Filter: ${result.data.length} ads | ${fromFormatted} to ${toFormatted})`;

                    showAlert('success', `Found ${result.data.length} ads from database between ${fromFormatted} and ${toFormatted}`);
                } else {
                    showAlert('error', 'Failed to query database for time range');
                }
            } catch (error) {
                console.error('Failed to filter database by time:', error);
                showAlert('error', 'Failed to filter database by time range');
            }
        }

        // Update session filter info display
        function updateSessionFilterInfo() {
            const sessionSelector = document.getElementById('sessionSelector');
            const sessionFilterInfo = document.getElementById('sessionFilterInfo');
            const currentSession = sessionSelector.value;

            if (currentSession) {
                const selectedOption = sessionSelector.options[sessionSelector.selectedIndex];
                sessionFilterInfo.textContent = `Filtering within: ${selectedOption.textContent}`;
            } else {
                sessionFilterInfo.textContent = 'Filtering current session (or all data if no session)';
            }
        }

        // Set quick date ranges
        function setQuickRange(range) {
            const now = new Date();
            const fromInput = document.getElementById('customTimeFrom');
            const toInput = document.getElementById('customTimeTo');

            let fromDate, toDate;

            switch (range) {
                case 'today':
                    fromDate = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0);
                    toDate = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59);
                    break;
                case 'yesterday':
                    fromDate = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 1, 0, 0);
                    toDate = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 1, 23, 59);
                    break;
                case 'week':
                    const weekStart = new Date(now);
                    weekStart.setDate(now.getDate() - now.getDay()); // Start of week (Sunday)
                    weekStart.setHours(0, 0, 0, 0);
                    fromDate = weekStart;
                    toDate = new Date(now);
                    break;
                case 'last24h':
                    fromDate = new Date(now.getTime() - 24 * 60 * 60 * 1000);
                    toDate = new Date(now);
                    break;
                default:
                    return;
            }

            // Format dates for datetime-local input
            fromInput.value = formatDateTimeLocal(fromDate);
            toInput.value = formatDateTimeLocal(toDate);

            // Auto-apply the filter
            applyCustomTimeFilter();
        }

        // Helper function to format date for datetime-local input
        function formatDateTimeLocal(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            return `${year}-${month}-${day}T${hours}:${minutes}`;
        }

        // Clear time filters and reload session
        async function clearTimeFilters() {
            // Clear the date inputs
            document.getElementById('customTimeFrom').value = '';
            document.getElementById('customTimeTo').value = '';

            // Reset time filter dropdown
            document.getElementById('timeframeFilter').value = '';

            document.getElementById('adsLoading').classList.add('active');

            try {
                // Reload the current session or all data
                const sessionSelector = document.getElementById('sessionSelector');
                const currentSession = sessionSelector.value;

                if (currentSession) {
                    // Reload the full session
                    await loadSession(currentSession);
                    showAlert('success', 'Time filters cleared - showing full session');
                } else {
                    // Reload current session ads
                    await loadAds();
                    await updateSessionInfo();
                    showAlert('success', 'Time filters cleared - showing current session');
                }
            } catch (error) {
                console.error('Failed to clear filters:', error);
                showAlert('error', 'Failed to clear filters');
            } finally {
                document.getElementById('adsLoading').classList.remove('active');
            }
        }

        // Download image function
        async function downloadImage(imageUrl, fileName) {
            try {
                // Use our server proxy to bypass CORS
                const proxyUrl = `/api/download-image?url=${encodeURIComponent(imageUrl)}`;

                const response = await fetch(proxyUrl);
                if (!response.ok) {
                    throw new Error('Failed to fetch image');
                }

                const blob = await response.blob();
                const objectUrl = URL.createObjectURL(blob);

                // Create a temporary anchor element and trigger download
                const link = document.createElement('a');
                link.href = objectUrl;
                link.download = `${fileName.replace(/[^a-z0-9]/gi, '_').toLowerCase()}_${Date.now()}.jpg`;
                link.style.display = 'none';

                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                // Clean up object URL after a delay
                setTimeout(() => URL.revokeObjectURL(objectUrl), 1000);

                showAlert('success', 'Image downloaded successfully');
            } catch (error) {
                console.error('Failed to download image:', error);
                showAlert('error', 'Failed to download image. Please try again.');
            }
        }

        // Auto-refresh ads - faster when extraction is running
        let autoRefreshInterval = null;
        const startAutoRefresh = () => {
            if (autoRefreshInterval) clearInterval(autoRefreshInterval);

            // Check status badge to determine if extraction is running
            const checkAndRefresh = () => {
                const isRunning = document.getElementById('statusBadge')?.textContent === 'running';
                const sessionSelector = document.getElementById('sessionSelector');

                if (isRunning) {
                    // When running, always load current session (empty string = current)
                    loadAds('');
                } else if (sessionSelector && sessionSelector.value) {
                    // When not running, load selected session
                    loadAds(sessionSelector.value);
                } else {
                    // Default to current session
                    loadAds('');
                }
                loadStats();
            };

            // Faster refresh when extraction is running
            const isRunning = document.getElementById('statusBadge')?.textContent === 'running';
            const interval = isRunning ? 5000 : 30000;

            autoRefreshInterval = setInterval(checkAndRefresh, interval);
        };

        // Start auto-refresh and update interval when status changes
        startAutoRefresh();
        setInterval(() => {
            // Restart with appropriate interval
            startAutoRefresh();
        }, 10000); // Check if we need to change refresh rate every 10 seconds

        // Functions for resumable extractions
        function showResumableExtraction(extraction) {
            // Show status panel with resume option
            const statusPanel = document.getElementById('statusPanel');
            const logsContainer = document.getElementById('logsContainer');
            const statusBadge = document.getElementById('statusBadge');
            const stopBtn = document.getElementById('stopBtn');

            statusPanel.classList.remove('hidden');
            statusBadge.textContent = 'Resumable';
            statusBadge.className = 'status-badge';
            statusBadge.style.backgroundColor = '#17a2b8';

            // Calculate idle time
            const idleMinutes = Math.round((extraction.resumeData?.idleTime || 0) / 60000);

            logsContainer.innerHTML = `
                <div style="padding: 20px; text-align: center; background: #f8f9fa; border-radius: 8px;">
                    <h4 style="color: #0066cc; margin-bottom: 15px;">🔄 Extraction Available for Resume</h4>
                    <p style="margin-bottom: 15px; color: #666;">
                        Previous extraction was stopped ${idleMinutes} minutes ago but session is preserved.
                    </p>
                    <div style="margin-bottom: 15px; font-size: 14px; color: #888;">
                        <strong>URL:</strong> ${extraction.url}<br>
                        <strong>Mode:</strong> ${extraction.extractionMode} (${extraction.deviceMode})<br>
                        <strong>Session:</strong> ${extraction.sessionFile || 'N/A'}
                    </div>
                    <button onclick="resumeExtraction('${extraction.id}')" class="btn btn-success" style="margin-right: 10px;">
                        ▶️ Resume Extraction
                    </button>
                    <button onclick="startNewExtraction()" class="btn btn-primary">
                        🆕 Start New Instead
                    </button>
                </div>
            `;

            // Hide stop button, show as resumable
            stopBtn.style.display = 'none';

            // Store extraction ID for resume
            window.resumableExtractionId = extraction.id;
        }

        async function resumeExtraction(extractionId) {
            try {
                showAlert('info', 'Resuming extraction...');

                const response = await fetch(`/api/extract/resume/${extractionId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();

                if (response.ok) {
                    showAlert('success', 'Extraction resumed successfully!');

                    // Update UI for running extraction
                    const statusBadge = document.getElementById('statusBadge');
                    const stopBtn = document.getElementById('stopBtn');
                    const logsContainer = document.getElementById('logsContainer');

                    statusBadge.textContent = 'Running';
                    statusBadge.className = 'status-badge';
                    statusBadge.style.backgroundColor = '#28a745';

                    stopBtn.style.display = 'inline-block';
                    stopBtn.disabled = false;

                    logsContainer.innerHTML = '<div>Extraction resumed, waiting for updates...</div>';

                    // Start monitoring
                    currentExtractionId = extractionId;
                    window.currentExtractionId = extractionId;
                    startStatusMonitoring();

                } else {
                    showAlert('error', `Failed to resume: ${data.details || data.error}`);
                }
            } catch (error) {
                showAlert('error', `Resume failed: ${error.message}`);
            }
        }

        function startNewExtraction() {
            // Hide status panel and allow new extraction
            document.getElementById('statusPanel').classList.add('hidden');
            window.resumableExtractionId = null;
            showAlert('info', 'Ready to start new extraction');
        }
    </script>
</body>
</html>